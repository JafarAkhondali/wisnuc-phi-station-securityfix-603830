<!-- TOC -->

- [1. 概述](#1-概述)
- [2. 使用](#2-使用)
  - [2.1. 创建](#21-创建)
  - [2.2. 命名冲突](#22-命名冲突)
    - [2.2.1. 策略](#221-策略)
    - [2.2.2. Policy对象](#222-policy对象)
    - [2.2.3. 全局策略和每个子任务策略](#223-全局策略和每个子任务策略)
  - [2.3. 错误](#23-错误)
- [3. 实现](#3-实现)
  - [3.1. 模型](#31-模型)
  - [3.2. 依赖性](#32-依赖性)
  - [3.3. 静态结构](#33-静态结构)
  - [3.4. 行为](#34-行为)
    - [3.4.1. 状态](#341-状态)
    - [3.4.2. 生命周期方法](#342-生命周期方法)
    - [3.4.3. 事件](#343-事件)
    - [3.4.4. 组合事件](#344-组合事件)
    - [3.4.5. 调度](#345-调度)

<!-- /TOC -->

# 1. 概述

`xcopy`模块提供在服务器端批量复制和移动文件的功能。该功能实现不持久化，如果服务重启，任务消失。

# 2. 使用

## 2.1. 创建

创建一个xcopy任务需要提供：

+ 模式，包括`copy`, `move`, `import`和`export`
  + 在fruitmix文件系统内部的复制和移动使用`copy`和`move`
  + 从外部文件系统导入到fruitmix文件系统使用`import`
  + 从fruitmix文件系统导出到外部文件系统使用`export`
+ 一个源文件夹标识
+ 源文件夹下的一组文件或文件夹，以名称做标识
+ 一个目标文件夹标识

```js
{
  mode: 'copy',
  src: {
    drive: '虚拟盘uuid，或物理盘device name',
    dir: '文件夹uuid，或文件夹相对路径'
  },
  dst: {
    drive: '虚拟盘uuid，或物理盘device name',
    dir: '文件夹uuid，或文件夹相对路径'
  },
  entries: ['文件夹或文件名']，
  policies: {
    dir: [null, null],  // 用于文件夹操作遇到命名冲突时的解决策略   
    file: [null, null]  // 用于文件操作遇到命名冲突时的解决策略
  }
}
```

## 2.2. 命名冲突

### 2.2.1. 策略

1. `undefined`或`null`, 无策略；当遇到同名对象时操作进入conflict状态，等待用户（客户端）解决；
2. `skip`, 遇到同名对象时跳过；如果源对象为文件夹，该文件夹内部的子文件夹和文件不会被继续复制或移动；
3. `merge`, 仅适用于源对下为文件夹且目标同名对象也为文件夹的情形，源文件夹内的子文件夹或文件会被继续复制或移动；
4. `replace`, 删除目标同名对象以完成复制或移动；
5. `rename`, 自动重命名；

### 2.2.2. Policy对象

1. Policy对象区分源对象和目标同名对象是相同类型还是不同类型；
2. 针对文件夹和文件使用不同的Policy；

每个policy对象用数组`[same, diff]`表示，其中`same`和`diff`分别为类型相同和类型不同时的策略；


### 2.2.3. 全局策略和每个子任务策略

全局具有`polices`属性，可以在创建任务时指定，也可以在任务运行时更新；更新全局`policies`一般在用户设置某个具体冲突时，在客户端提供“应用全部”选项，客户端可以根据该用户操作更新全局策略。

每个子任务也有自己的policy，目前的设计，每个子任务具有预设类型（根据源对象的类型）且不会变化，所以更新子任务的policy只需要提供一个policy对象。

全局策略的更新影响到所有已经冲突的任务，也影响到正在执行的任务。


## 2.3. 错误

可以预见到的错误包括如下类型：

1. 用户权限错误
  1. 用户不再能够访问源或目标文件夹
2. 源对象访问错误，包括：
  1. 源对象丢失
  2. 源对象类型变化
  3. 源对象为不支持的文件类型
3. 目标对象访问呢错误，包括：
  1. 目标对象为不支持的类型
4. 结构性错误
  1. 源对象的父文件夹、乃至整个任务的源文件夹，无法访问
  2. 目标对象的父文件夹、乃至整个任务的目标文件夹，无法访问


# 3. 实现

## 3.1. 模型

`xcopy`设计为代表用户执行一组动作，它位于VFS的外面，使用VFS提供的方法完成整个任务。

`xcopy`在参数中用name作为文件标识。

## 3.2. 依赖性

xcopy模块依赖vfs提供如下接口：

+ readdir (copy, move, export，读取源文件夹)
+ cpdir (copy)
+ cpfile (copy)
+ mvdir (move)
+ mvfile （move)
+ tmpfile (import)
+ mkdir (import)
+ mkfile (import)
+ clone (export)

xcopy模块依赖nfs提供如下接口：

+ getFs (import, export，获取文件系统挂载点)


## 3.3. 静态结构

`xcopy`使用组合状态机实现；

顶层任务容器本身由`copy`, `move`, `import`, `export`四个子类分别实现对应业务，具有共同的基类`base`；

`File`是复制或移动一个文件的基类，具有四个子类`FileCopy`, `FileMove`, `FileImport`和`FileExport`；

`Dir`是复制或移动一个文件夹的基类，具有四个子类`DirCopy`, `DirMove`, `DirImport`和`DirExport`；

`File`和`Dir`均继承自`Node`，是`EventEmitter`，使用**同步**方式emit状态变化；

## 3.4. 行为

### 3.4.1. 状态

File具有`Pending`, `Working`, `Conflict`, `Failed`和`Finished`五个状态；

`Pending`是等待调度的状态，只有调度器可以改变该状态；

`Working`是正在复制或者移动文件的状态；

`Conflict`是冲突状态，用户可以修改；

`Failed`和`Finished`分别是失败和成功状态；

Dir具有`Pending`, `Working`, `Reading`, `Read`, `Failed`和`Finished`五个状态；

`Pending`是等待调度的状态，只有调度器可以改变该状态；

`Working`是正在复制或者移动文件夹的状态；

`Reading`是在创建目标文件夹成功后，读取源文件夹内容的状态；该操作成功后会创建子任务；

`Read`是等待全部子任务完成的状态；

`Failed`和`Finished`分别是失败和成功状态；

### 3.4.2. 生命周期方法

destroy操作设计为析构意义上的对象销毁，而不是对象在destroy之后需要异步迁移到成功或失败的结束状态，所以destroy可以用同步方法实现；这要求每个`Node`对象都实现destroy方法；对于执行操作的状态，应使用状态变量block操作的继续。

### 3.4.3. 事件




### 3.4.4. 组合事件

Dir节点在Read状态下会获得子节点组合事件；



### 3.4.5. 调度













